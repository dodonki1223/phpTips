# バイナリセーフな関数とそうでない関数について

## バイナリセーフとはどのような関数なのか……よくわからないのでバイナリセーフな関数についてまとめる

### バイナリセーフな関数
バイナリデータを正しく扱うことができる関数

### バイナリセーフでない関数
バイナリデータを正しく扱うことができない関数

### そもそもバイナリデータとは？
コンピュータが扱えるよう2進法に則って0と1の羅列(ビット列)として表現されたデータうち、テキスト(文字)形式ではない任意のデータ形式のこと。
※[http://e-words.jp/w/%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA.html より引用](http://e-words.jp/w/%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA.html)

### 結局、気をつけることは何？
バイナリセーフでない関数を使用するとNULLバイト攻撃にあう

### Nullバイト攻撃とは？
nullバイト（「**\0**」、「**\x00**」などの終端文字とされている文字列）を含めることでセキュリティチェックをくぐり抜けてしまう。
ロケールに基づく文字列比較の関数（strcoll、strcmp）を使用して確認してみる。
返り値は[str1 が str2 よりも小さければ < 0 を、str1が str2よりも大きければ > 0 を、 等しければ 0 を返します。 ※strcmpの公式リファレンスより](http://php.net/manual/ja/function.strcmp.php)

### 表示結果

```shell
LC_COLLATE=ja_JP.UTF-8;LC_CTYPE=Japanese_Japan.932;LC_MONETARY=C;LC_NUMERIC=C;LC_TIME=C

strcoll：2147483647
strcmp：-1
```
